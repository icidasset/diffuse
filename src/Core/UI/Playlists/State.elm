module UI.Playlists.State exposing (..)

import Conditional exposing (ifThenElse)
import Coordinates
import Html.Events.Extra.Mouse as Mouse
import List.Ext as List
import List.Extra as List
import Maybe.Extra as Maybe
import Notifications
import Playlists exposing (..)
import Return exposing (andThen)
import Tracks exposing (IdentifiedTrack)
import Tracks.Collection
import UI.Alfred.State as Alfred
import UI.Common.State as Common
import UI.Page as Page
import UI.Playlists.Alfred
import UI.Playlists.ContextMenu as Playlists
import UI.Playlists.Page exposing (..)
import UI.Tracks.State as Tracks
import UI.Types exposing (..)
import UI.User.State.Export as User



-- ğŸ”±


activate : Playlist -> Manager
activate playlist model =
    model
        |> select playlist
        |> andThen (Common.changeUrlUsingPage Page.Index)


addTracksToPlaylist : { playlistName : String, tracks : List PlaylistTrack } -> Manager
addTracksToPlaylist { playlistName, tracks } model =
    let
        properPlaylistName =
            String.trim playlistName

        playlistIndex =
            List.findIndex
                (\p -> Maybe.isNothing p.autoGenerated && p.name == properPlaylistName)
                model.playlists

        newCollection =
            case playlistIndex of
                Just idx ->
                    List.updateAt
                        idx
                        (\p -> { p | tracks = p.tracks ++ tracks })
                        model.playlists

                Nothing ->
                    { autoGenerated = Nothing
                    , name = properPlaylistName
                    , public = False
                    , tracks = tracks
                    }
                        :: model.playlists

        newModel =
            { model
                | playlists = newCollection
                , lastModifiedPlaylist = Just properPlaylistName
            }
    in
    (case tracks of
        [ t ] ->
            "Added __" ++ t.title ++ "__"

        l ->
            "Added __" ++ String.fromInt (List.length l) ++ " tracks__"
    )
        |> (\s -> s ++ " to the __" ++ properPlaylistName ++ "__ playlist")
        |> Notifications.success
        |> Common.showNotificationWithModel newModel
        |> andThen User.savePlaylists


assistWithAddingTracksToPlaylist : List IdentifiedTrack -> Manager
assistWithAddingTracksToPlaylist tracks model =
    model.playlists
        |> List.filterNot (.autoGenerated >> Maybe.isJust)
        |> UI.Playlists.Alfred.create tracks
        |> (\a -> Alfred.assign a model)


assistWithSelectingPlaylist : Manager
assistWithSelectingPlaylist model =
    model.playlists
        |> UI.Playlists.Alfred.select
        |> (\a -> Alfred.assign a model)


create : Manager
create model =
    case model.newPlaylistContext of
        Just playlistName ->
            let
                alreadyExists =
                    List.any
                        (.name >> (==) playlistName)
                        (List.filterNot (.autoGenerated >> Maybe.isJust) model.playlists)

                playlist =
                    { autoGenerated = Nothing
                    , name = playlistName
                    , public = False
                    , tracks = []
                    }
            in
            if alreadyExists then
                "There's already a playlist with this name"
                    |> Notifications.error
                    |> Common.showNotificationWithModel model

            else
                { model
                    | lastModifiedPlaylist = Just playlist.name
                    , newPlaylistContext = Nothing
                    , playlists = playlist :: model.playlists
                }
                    |> User.savePlaylists
                    |> andThen redirectToPlaylistIndexPage

        Nothing ->
            Return.singleton model


deactivate : Manager
deactivate =
    deselect


deselect : Manager
deselect model =
    { model | selectedPlaylist = Nothing }
        |> Tracks.reviseCollection Tracks.Collection.arrange
        |> andThen User.saveEnclosedUserData


delete : { playlistName : String } -> Manager
delete { playlistName } model =
    let
        selectedPlaylist =
            Maybe.map
                (\p -> ( p.autoGenerated, p.name ))
                model.selectedPlaylist

        ( selectedPlaylistChanged, newSelectedPlaylist ) =
            if selectedPlaylist == Just ( Nothing, playlistName ) then
                ( True, Nothing )

            else
                ( False, model.selectedPlaylist )
    in
    model.playlists
        |> List.filter
            (\p ->
                if Maybe.isJust p.autoGenerated then
                    True

                else
                    p.name /= playlistName
            )
        |> (\col ->
                { model
                    | playlists = col
                    , selectedPlaylist = newSelectedPlaylist
                }
           )
        |> (if selectedPlaylistChanged then
                Tracks.reviseCollection Tracks.Collection.arrange

            else
                Return.singleton
           )
        |> andThen User.savePlaylists


modify : Manager
modify model =
    case model.editPlaylistContext of
        Just { oldName, newName } ->
            let
                properName =
                    String.trim newName

                validName =
                    String.isEmpty properName == False

                ( autoGenerated, notAutoGenerated ) =
                    List.partition (.autoGenerated >> Maybe.isJust) model.playlists

                alreadyExists =
                    List.any
                        (.name >> (==) properName)
                        notAutoGenerated

                newCollection =
                    List.map
                        (\p -> ifThenElse (p.name == oldName) { p | name = properName } p)
                        notAutoGenerated
            in
            if alreadyExists then
                "There's already a playlist with this name"
                    |> Notifications.error
                    |> Common.showNotificationWithModel
                        { model | editPlaylistContext = Nothing }

            else if validName then
                { model
                    | editPlaylistContext = Nothing
                    , lastModifiedPlaylist = Just properName
                    , playlists = newCollection ++ autoGenerated
                }
                    |> User.savePlaylists
                    |> andThen redirectToPlaylistIndexPage

            else
                redirectToPlaylistIndexPage model

        Nothing ->
            redirectToPlaylistIndexPage model


moveTrackInSelected : { to : Int } -> Manager
moveTrackInSelected { to } model =
    case model.selectedPlaylist of
        Just playlist ->
            let
                moveParams =
                    { from = Maybe.withDefault 0 (List.head model.selectedTrackIndexes)
                    , to = to
                    , amount = List.length model.selectedTrackIndexes
                    }

                updatedPlaylist =
                    { playlist | tracks = List.move moveParams playlist.tracks }

                updatedPlaylistCollection =
                    List.map
                        (\p ->
                            ifThenElse
                                (p.autoGenerated == Nothing && p.name == updatedPlaylist.name)
                                updatedPlaylist
                                p
                        )
                        model.playlists
            in
            { model
                | playlists = updatedPlaylistCollection
                , selectedPlaylist = Just updatedPlaylist
            }
                |> Tracks.reviseCollection Tracks.Collection.arrange
                |> andThen User.savePlaylists

        Nothing ->
            Return.singleton model


removeTracks : Playlist -> List IdentifiedTrack -> Manager
removeTracks playlist tracks model =
    let
        updatedPlaylist =
            Tracks.removeFromPlaylist tracks playlist
    in
    model.playlists
        |> List.map
            (\p ->
                if p.name == playlist.name then
                    updatedPlaylist

                else
                    p
            )
        |> (\c -> { model | playlists = c })
        |> select updatedPlaylist
        |> andThen User.savePlaylists


select : Playlist -> Manager
select playlist model =
    { model | page = Page.Index, selectedPlaylist = Just playlist }
        |> Tracks.reviseCollection Tracks.Collection.arrange
        |> andThen User.saveEnclosedUserData


setCreationContext : String -> Manager
setCreationContext playlistName model =
    Return.singleton { model | newPlaylistContext = Just playlistName }


setModificationContext : String -> String -> Manager
setModificationContext oldName newName model =
    let
        context =
            { oldName = oldName
            , newName = newName
            }
    in
    Return.singleton { model | editPlaylistContext = Just context }


showListMenu : Playlist -> Mouse.Event -> Manager
showListMenu playlist mouseEvent model =
    let
        coordinates =
            Coordinates.fromTuple mouseEvent.clientPos

        contextMenu =
            Playlists.listMenu
                playlist
                model.tracks.identified
                model.confirmation
                coordinates
    in
    Return.singleton { model | contextMenu = Just contextMenu }


toggleVisibility : Playlist -> Manager
toggleVisibility playlist model =
    let
        updatedPlaylist =
            { playlist | public = not playlist.public }
    in
    model.playlists
        |> List.map
            (\p ->
                if p.name == playlist.name then
                    updatedPlaylist

                else
                    p
            )
        |> (\c -> { model | playlists = c })
        |> User.savePlaylists



-- ãŠ™ï¸


redirectToPlaylistIndexPage : Manager
redirectToPlaylistIndexPage =
    Common.changeUrlUsingPage (Page.Playlists Index)
