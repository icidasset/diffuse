module Tracks.Collection.Internal
    exposing
        ( build
        , buildf
        , partial
        , initialize
        , identify
        , harvest
        , expose
        )

import Bool.Extra exposing (ternary)
import List.Extra as List exposing ((!!))
import Maybe.Extra as Maybe
import Playlists.Types exposing (..)
import Playlists.Utils exposing (..)
import Tracks.Favourites as Favourites
import Tracks.Sorting as Sorting
import Tracks.Types exposing (..)


build : List Track -> Parcel -> Parcel
build tracks =
    initialize tracks >> identify >> harvest >> expose


buildf : Parcel -> List Track -> Parcel
buildf =
    flip build


partial : Int
partial =
    50



-- Initialize


initialize : List Track -> Parcel -> Parcel
initialize tracks ( model, collection ) =
    (,) model { collection | untouched = tracks }



-- Identifying


identify : Parcel -> Parcel
identify ( model, collection ) =
    let
        playlistTracks =
            model.selectedPlaylist
                |> Maybe.map identifyPlaylistTracks
                |> Maybe.withDefault []

        enabledOnly =
            List.filter
                (\t -> List.member t.sourceId model.enabledSourceIds)
                collection.untouched

        ( identifiedUnsorted, missingFavourites, missingPlaylistTracks ) =
            List.foldr
                (identifier model.favourites model.activeIdentifiedTrack)
                ( [], model.favourites, playlistTracks )
                enabledOnly

        sortingFunction =
            model.selectedPlaylist
                |> Maybe.map .autoGenerated
                |> Maybe.andThen (ternary Nothing (Just 1))
                -- Playlist sort
                |> Maybe.map (always <| Sorting.sort PlaylistIndex Asc)
                -- Default sort
                |> Maybe.withDefault (Sorting.sort model.sortBy model.sortDirection)
    in
        identifiedUnsorted
            |> List.append (List.map makeMissingFavouriteTrack missingFavourites)
            |> List.append (List.map makeMissingPlaylistTrack missingPlaylistTracks)
            |> sortingFunction
            |> (\x -> { collection | identified = x })
            |> (\x -> (,) model x)


identifier :
    List Favourite
    -> Maybe IdentifiedTrack
    -> Track
    -> ( List IdentifiedTrack, List Favourite, List IdentifiedPlaylistTrack )
    -> ( List IdentifiedTrack, List Favourite, List IdentifiedPlaylistTrack )
identifier favourites mait track ( acc, missingFavourites, missingPlaylistTracks ) =
    let
        lartist =
            String.toLower track.tags.artist

        ltitle =
            String.toLower track.tags.title

        favouriteMatcher =
            Favourites.matcher lartist ltitle

        isFavourite =
            List.any favouriteMatcher favourites

        playlistIndex =
            List.findIndex
                (Tuple.second >> trackWithPlaylistTrackMatcher track)
                missingPlaylistTracks

        identifiedPlaylistTrack =
            Maybe.andThen
                ((!!) missingPlaylistTracks)
                playlistIndex

        indexInPlaylist =
            Maybe.map
                (Tuple.first >> .index)
                identifiedPlaylistTrack

        isNowPlaying =
            case mait of
                Just ( identifiers, activeTrack ) ->
                    case indexInPlaylist of
                        Just idx ->
                            track.id == activeTrack.id && Just idx == identifiers.indexInPlaylist

                        Nothing ->
                            track.id == activeTrack.id

                Nothing ->
                    False

        identifiedTrack =
            (,)
                { indexInPlaylist = indexInPlaylist
                , isFavourite = False
                , isMissing = False
                , isNowPlaying = isNowPlaying
                }
                track

        missingPlaylistTracks_ =
            case playlistIndex of
                Just idx ->
                    List.removeAt idx missingPlaylistTracks

                Nothing ->
                    missingPlaylistTracks
    in
        case isFavourite of
            -- A favourite
            --
            True ->
                ( identifiedTrack
                    |> Tuple.mapFirst (\i -> { i | isFavourite = True })
                    |> (flip (::)) acc
                  --
                , if isFavourite then
                    List.filterNot favouriteMatcher missingFavourites
                  else
                    missingFavourites
                  --
                , missingPlaylistTracks_
                )

            -- Not a favourite
            --
            False ->
                ( identifiedTrack :: acc
                , missingFavourites
                , missingPlaylistTracks_
                )


identifyPlaylistTracks : Playlist -> List IdentifiedPlaylistTrack
identifyPlaylistTracks playlist =
    List.indexedMap identifyPlaylistTrack playlist.tracks


identifyPlaylistTrack : Int -> PlaylistTrack -> IdentifiedPlaylistTrack
identifyPlaylistTrack index playlistTrack =
    (,) { index = index } playlistTrack


makeMissingFavouriteTrack : Favourite -> IdentifiedTrack
makeMissingFavouriteTrack fav =
    let
        tags =
            { disc = 1
            , nr = 0
            , artist = fav.artist
            , title = fav.title
            , album = "<missing>"
            , genre = Nothing
            , picture = Nothing
            , year = Nothing
            }
    in
        (,)
            { indexInPlaylist = Nothing
            , isFavourite = True
            , isMissing = True
            , isNowPlaying = False
            }
            { tags = tags
            , id = missingId
            , path = missingId
            , sourceId = missingId
            }


makeMissingPlaylistTrack : IdentifiedPlaylistTrack -> IdentifiedTrack
makeMissingPlaylistTrack ( identifiers, playlistTrack ) =
    let
        tags =
            { disc = 1
            , nr = 0
            , artist = playlistTrack.artist
            , title = playlistTrack.title
            , album = playlistTrack.album
            , genre = Nothing
            , picture = Nothing
            , year = Nothing
            }
    in
        (,)
            { indexInPlaylist = Just identifiers.index
            , isFavourite = False
            , isMissing = True
            , isNowPlaying = False
            }
            { tags = tags
            , id = missingId
            , path = missingId
            , sourceId = missingId
            }



-- Harvesting


harvest : Parcel -> Parcel
harvest ( model, collection ) =
    let
        harvested =
            case model.searchResults of
                Just [] ->
                    []

                Just trackIds ->
                    collection.identified
                        |> List.foldl harvester ( [], trackIds )
                        |> Tuple.first

                Nothing ->
                    collection.identified

        filters =
            [ --
              -- Favourites / Missing
              if model.favouritesOnly then
                Tuple.first >> .isFavourite >> (==) True
              else if Maybe.isJust model.selectedPlaylist then
                always True
              else
                Tuple.first >> .isMissing >> (==) False

            --
            -- Playlists
            , case model.selectedPlaylist of
                Just playlist ->
                    case playlist.autoGenerated of
                        True ->
                            \( _, t ) ->
                                t.path
                                    |> String.split "/"
                                    |> List.head
                                    |> Maybe.withDefault ""
                                    |> (==) playlist.name

                        False ->
                            \( i, _ ) ->
                                Maybe.isJust i.indexInPlaylist

                Nothing ->
                    always True
            ]

        theFilter =
            \x ->
                List.foldl
                    (\filter bool ->
                        if bool == True then
                            filter x
                        else
                            bool
                    )
                    True
                    filters
    in
        (,)
            model
            { collection | harvested = List.filter theFilter harvested }


harvester :
    IdentifiedTrack
    -> ( List IdentifiedTrack, List TrackId )
    -> ( List IdentifiedTrack, List TrackId )
harvester ( i, t ) ( acc, trackIds ) =
    case List.findIndex ((==) t.id) trackIds of
        Just idx ->
            ( acc ++ [ ( i, t ) ]
            , List.removeAt idx trackIds
            )

        Nothing ->
            ( acc
            , trackIds
            )



-- Exposing


expose : Parcel -> Parcel
expose ( model, collection ) =
    (,)
        model
        { collection | exposed = List.take (model.exposedStep * partial) collection.harvested }
