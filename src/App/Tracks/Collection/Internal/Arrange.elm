module Tracks.Collection.Internal.Arrange exposing (arrange)

import List.Ext as List
import List.Extra as List exposing ((!!))
import Maybe.Extra as Maybe
import Playlists.Types exposing (..)
import Playlists.Utils exposing (..)
import Tracks.Sorting as Sorting
import Tracks.Types exposing (..)
import Tracks.Utils exposing (isNowPlaying)


-- ðŸ¯


arrange : Parcel -> Parcel
arrange parcel =
    parcel
        |> Tuple.mapFirst .selectedPlaylist
        |> Tuple.first
        |> Maybe.andThen
            (\playlist ->
                if playlist.autoGenerated then
                    Nothing
                else
                    Just playlist
            )
        |> Maybe.map (arrangePlaylist parcel)
        |> Maybe.withDefault (arrangeRegular parcel)



-- Arranging


arrangeRegular : Parcel -> Parcel
arrangeRegular ( model, collection ) =
    collection.identified
        |> Sorting.sort model.sortBy model.sortDirection
        |> (\x -> { collection | arranged = x })
        |> (\x -> (,) model x)


arrangePlaylist : Parcel -> Playlist -> Parcel
arrangePlaylist ( model, collection ) playlist =
    collection.identified
        |> matchWithPlaylist model playlist
        |> Sorting.sort PlaylistIndex Asc
        |> (\x -> { collection | arranged = x })
        |> (\x -> (,) model x)



-- Playlists


matchWithPlaylist : Tracks.Types.Model -> Playlist -> List IdentifiedTrack -> List IdentifiedTrack
matchWithPlaylist model playlist tracks =
    let
        playlistTracks =
            identifyPlaylistTracks playlist

        ( unsorted, missingPlaylistTracks ) =
            List.foldl
                (playlistMatcher model.activeIdentifiedTrack)
                ( [], playlistTracks )
                tracks
    in
        List.append
            (List.map makeMissingPlaylistTrack missingPlaylistTracks)
            (unsorted)


playlistMatcher :
    Maybe IdentifiedTrack
    -> IdentifiedTrack
    -> ( List IdentifiedTrack, List IdentifiedPlaylistTrack )
    -> ( List IdentifiedTrack, List IdentifiedPlaylistTrack )
playlistMatcher nowPlaying identifiedTrack ( acc, reducingPlaylistTracks ) =
    let
        matcher =
            identifiedTrack
                |> Tuple.second
                |> trackWithIdentifiedPlaylistTrackMatcher

        ( matches, remainingPlaylistTracks ) =
            List.foldl
                (\playlistTrack acc ->
                    if matcher playlistTrack then
                        Tuple.mapFirst ((::) playlistTrack) acc
                    else
                        Tuple.mapSecond ((::) playlistTrack) acc
                )
                ( [], [] )
                reducingPlaylistTracks

        identifiedTracks =
            List.map
                (buildTrack nowPlaying identifiedTrack)
                matches
    in
        ( List.append identifiedTracks acc
        , remainingPlaylistTracks
        )


buildTrack : Maybe IdentifiedTrack -> IdentifiedTrack -> IdentifiedPlaylistTrack -> IdentifiedTrack
buildTrack nowPlaying identifiedTrack ( { index }, _ ) =
    let
        identifiedTrackWithIndex =
            Tuple.mapFirst
                (\i -> { i | indexInPlaylist = Just index })
                identifiedTrack

        now =
            nowPlaying
                |> Maybe.map (isNowPlaying identifiedTrackWithIndex)
                |> Maybe.withDefault False
    in
        Tuple.mapFirst
            (\i -> { i | isNowPlaying = now })
            identifiedTrackWithIndex



-- Playlists / Identifying


identifyPlaylistTracks : Playlist -> List IdentifiedPlaylistTrack
identifyPlaylistTracks playlist =
    List.indexedMap identifyPlaylistTrack playlist.tracks


identifyPlaylistTrack : Int -> PlaylistTrack -> IdentifiedPlaylistTrack
identifyPlaylistTrack index playlistTrack =
    (,) { index = index } playlistTrack



-- Playlists / Missing tracks


makeMissingPlaylistTrack : IdentifiedPlaylistTrack -> IdentifiedTrack
makeMissingPlaylistTrack ( identifiers, playlistTrack ) =
    let
        tags =
            { disc = 1
            , nr = 0
            , artist = playlistTrack.artist
            , title = playlistTrack.title
            , album = playlistTrack.album
            , genre = Nothing
            , picture = Nothing
            , year = Nothing
            }
    in
        (,)
            { indexInPlaylist = Just identifiers.index
            , isFavourite = False
            , isMissing = True
            , isNowPlaying = False
            }
            { tags = tags
            , id = missingId
            , path = missingId
            , sourceId = missingId
            }
